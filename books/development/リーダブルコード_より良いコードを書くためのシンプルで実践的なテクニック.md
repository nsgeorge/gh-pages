---
layout: default
description: リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック (Theory in practice), Dustin Boswell, Trevor Foucher, 須藤 功平, 角 征典
---

# [リーダブルコード](https://www.oreilly.co.jp/books/9784873115658/)

---

# 表面上の改善

---

## 名前に情報を詰め込む

 - **明確な単語を選ぶ**
   - 取得する先に応じた名前をつける
     - getPage: どこから持ってくるのかわからない（おそらく軽量アクセサ）
     - downloadPage: HTTP通信してそうな意味が付加される
     - selectPage: DBからデータを取得してそうな意味が付加される
   - なんの値か明確にする
     - size(): なんのサイズかわからない
     - height(): 高さであることがわかる
     - memoryBytes(): 単位もついててよりGood
 - **一時的な変数でもちゃんと名前をつける**
   - tmp, retval, i, j等は避ける
     - 状況に応じた適切な変数名を使う
     - 例えば2乗値の計算なら、`tmp`よりも`sum_squares`を使う
     - 生存期間が数行の本当に一時的な値なら許容される
     - i, jなどのイテレータ用の変数も`user_i`や`shcool_j`などとしたほうがバグを見つけやすくなる
 - **名前に情報を付加する**
   - 変数名に単位をつけることで思わぬバグを防げる
     - xx_sec, xx_msec, xx_mb, xx_kb, xx_utf8, xx_sjis ...等
   - セキュアな情報にも活用できる
     - password -> plaintext_password(暗号化しなきゃ！)
     - comment -> unescaped_comment(エスケープしなきゃ！)
 - **独自の省略形や頭文字表記は避ける**
   - プロジェクト固有の省略表記は避ける
   - 一般的な省略表記は許容される
     - eval, doc, str ...等
 - **不要な単語は削除する**
   - convertToString()はtoString()にしても情報が失われない

## 誤解されない名前

 - **`filter("year <= 2011")`は選択する機能か除外する機能か？**
   - filterは曖昧な言葉なので使わない方が良い
   - 選択するのなら`select`とすべきだし
   - 除外するなら`exclude`とすべき
 - **限界値を決めるときは`min`と`max`を使う**
   - `XX_LIMIT`という定数は曖昧で、off-by-oneエラーを引き起こす
   - 限界値をmin, maxで表現することで限界値が明確になる
   - `count == max`か許容されるが`count > max`は許容されないことは明確
 - **範囲を指定するときは`first`と`last`を使う**
   - これも「未満」と「以下」の問題の一例
   - start, stopだとstopが包含なのかどうかがわからない
   - first, lastを使うことで包含していることが明確になる
   - 一方、包含／排他的範囲の場合は`begin`と`end`が分かりやすい
 - **ブール値の変数名／メソッド名の接頭辞**
   - is, has, can, shouldなどをつけてわかりやすくする
   - 否定形ではなく肯定形の形で表現する
     - `disable_ssl = false`より`use_ssl = true`を使う
 - **メソッドを呼び出す側の期待に合わせる**
   - `getSummary()`は軽量アクセサという印象を与える
   - `calculateSummary()`は何かしらの計算処理があるという印象を与える
     - メソッドのコストの高さがある程度表現できたほうが良い
 
> Off-by-one エラー - Murga  
> http://neos21.hatenablog.jp/entry/2017/02/04/003512

## 美しさ

 - **読み手のことを考えたレイアウトを意識する**
   - 読み手がなれているパターンと一貫性のあるレイアウトを使う
   - 似ているコードは似ているように見せる
   - 関連するコードをまとめてブロックにする
 - **縦の線をまっすぐにする**
   - 複数行に渡る連続する`=`の位置や変数の位置など
   - 見た目だけの問題ではなくて、タイプミスや引数の間違いなどに気づきやすくなる
 - **一貫性と意味のある並びにする**
   - コードの並びがロジックに関係ない場合、意味のある順番に並べると良い
   - タイプごと、重要な変数順、アルファベット順 ...など

## コメントすべき事を知る

 - **コードから「すぐに」分かることはコメントに書かない**
   - XXを定義する、XXを設定する、XXを画面に表示する ...等
   - ただし、この「すぐに」の部分が重要
   - コードを読むよりもコメントの方が早く理解できる場合は価値がある
 - **変数名、メソッド名の埋め合わせとしてコメントを使わない**
   - こういう場合は変数名やメソッド名の方を変えてコメントがなくても意味が通じるようにする
 - **自分の考えやその実装の背景をコメントとして残す**
   - コメントを読んだ人が無駄なテストや試行、リファクタリングをしないような情報が望ましい
   - 以下のような感じ
     - `// XXの実装よりこちらの実装のほうが高速なので採用した`
     - `// 本来XXすべきだが、YYの理由によりこちらの方式を採用せざるを得ない`
 - **定数にコメントをつける**
   - その定数の意味や根拠があればそれを書いておくことで後のチューニングや設定変更に役立つ
     - `// 2 * サーバー数以上の値にすること`
     - `// YYという理由からXX以上にはならないのでざっくりこの値にした`
 - **ハマりそうな罠を告知する**
   - 以下のような忠告があれば内部の実装を知らなくても罠を回避できる
     - `// メソッド内で外部サービスと通信している（1分でタイムアウトする）`
     - `// 大きいファイルファイルを解析するので大量のメモリを使う可能性がある`

## コメントは正確で簡潔に

 - **曖昧な代名詞を避ける**
   - それ、これ、あの ...等のコメントは誤解や誤った解釈に繋がるのでできるだけ避ける
 - **入出力のコーナーケースに実例を使う**
   - 関数の動作を説明する例としてその動作例を実際のin, outを使ってコメントする
   - `// "image.jpeg"から".jpeg"を除外して"image"を返す`
 - **コードの意図を書く**
   - プログラムの動作を高レベルで説明できているコメントは良いコメント
   - 実装の説明ではなく、その実装によりどういうことが実現されているのかを書くようにする
     - `// 配信可能なバナーを優先的に取り出す`
     - `// おすすめの商品順にソートする`
 - **名前付き引数コメント**
   - これはすごいテク（実務で使うかは微妙やけど）
   - Pythonとかやと`Connect(timeut_ms = 10, is_encripted = false);`と書ける
   - Javaとかやと`Connect(/* timeut_ms = */ 10, /* is_encripted = */ false);`みたいに書く

---

# ループとロジックの単純化

---

## 制御フローを読みやすくする

 - **左側に調査対象（変化する）、右側に比較対象（変化しない）をおく**
   - `if(length >= 10)` みたいな
   - `while(user_i < user_count)` みたいな
   - 普通にしてたらこうなるよねっていう
     - 実は文章の用法と合ってるから分かりやすい、という事らしい
     - `もし君の年齢が18歳以上なら...`は自然
     - `もし18年が君の年齢以下なら...`は不自然
 - **条件式には否定形よりも肯定形を使う**
   - `if(!isCompleted)`より`if(isProsessing)`
 - **行数を短くするよりも他の人が理解するのにかかる時間を短くする方を選ぶ**
   - 三項演算子は便利で短く記述できるが本当に分かりやすいか？と意識する
   - 場合によっては冗長でもif文を使って明確に記述したほうが良いこともある
 - **関数から早く返す**
   - 「ガード節」と呼ぶらしい
   - 条件を満たした時点でreturnするので、それ以降の実装を意識しなくて良いので可読性があがる
 - **ネストを浅くする**
   - 読み手はネストが増えるたびに脳内に条件をスタックし続けなければならない
   - ネストが深いと今自分が読んでいるコードがどういう条件なのかが分からなくなりやすい
   - if文全体をみて先にreturnできる条件がないか探す
     - こうすることですべてのifブロックがreturnで終わるならかなり可読性が上がる
     - 脳内のスタックからポップする必要がないため

## 巨大な式を分割する

 - **説明変数を使う**
   - 式を説明する変数を使えばより分かりやすくなるということ
   - `String username = list.get(0).split("_")[1]; if(username.equals("root"))`的な
 - **要約変数を使う**
   - 条件を要約する変数を使えばより分かりやすくなるということ
   - 条件を高い次元の概念として表現できる
   - `Boolean isCompleted = banner.getContent().getStatus() == ContentStatus.Complete`的な
 - **ド・モルガンの法則を使う**
   - `!(a || b || c)` = `!a && !b && !c`
   - `!(a && b && c)` = `!a || !b || !c`
   - Notを分配してandとorを反転する、と覚える
   - 基本的に置換後のほうが読みやすい
   - どういうときに使えるか？
     - `if(!(isCompleted || hasEmptyStatus))`みたいな条件は
     - `if(isNotCompleted && hasStatus)`に置き換えたほうが分かりやすい
 - **反対の条件から解決する**
   - 条件の組み合わせがあまりにも多い場合は、解決のアプローチが間違っていることがある
   - 反対の条件を洗い出して、それに該当しない場合は真とするとより簡潔に条件を表現できることがある

## 変数と読みやすさ

 - **役に立たない変数を削除する**
   - 関数から早くreturnすることで一時変数を削除できたりする
   - 削除しても可読性が下がらない場合は削除する
 - **変数のスコープを縮める、定義の位置を下げる**
   - スコープは小さい方がより安全
   - 関数の最初でまとめて定義する文化もあるが、利用する直前での定義のほうが可読性が高い
 - **イミュータブルな変数を活用する**
   - 値が変わらない変数は安全
   - const, finalを使える場合は積極的に使う

---

# コードの再構成

---

## 無関係の下位問題を抽出する

 - **メソッド内の処理が下位の無関係な問題を扱っている場合はそれを切り出す**
   - 下位の無関係な問題とは、それ単体で切り出して意味がある処理のこと
   - privateメソッドに切り出したり普段普通にやってることのように思う

## 一度に一つのことを

 - **メソッド内の処理を複数のタスクに分解して順番に処理する**
   - ループしながら抽出と条件判定と...等と一連の流れで処理してると理解が難しい
   - 1つ1つ完結したタスクに置き換えると理解しやすくなる
   
## コードに思いを込める

 - **やろうとしている処理を簡潔な言葉で説明してコメントに書いてみる**
   - 簡潔に書くことでロジックがシンプルになる
   - 無関係な下位問題を見つけることもできる
   - ラバーダッキングと呼ばれる技法に似てる

## 短いコードを書く

 - **身近なライブラリに親しむ**
   - APIでできることに気づけるかどうかが大きなカギ
   - 「この処理APIであったような・・・」という気付きが大切

